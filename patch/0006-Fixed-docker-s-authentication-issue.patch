From 71d29043d8e87fd70d270797e4044073e3fd0e9e Mon Sep 17 00:00:00 2001
From: Dan Walsh <dwalsh@redhat.com>
Date: Mon, 14 Dec 2015 17:14:49 -0500
Subject: [PATCH 06/13] Fixed docker's authentication issue

Docker client sends configuration file with stored credentials together
with several requests to Docker daemon. Daemon then takes the first
authentication information and tries to use it against any registry it
contacts. This results in authentication errors while trying pull from
any registry but the one stored first in configuration file. This patch
checks, whether the given credentials belong to desired endpoint before
creating an new session.

This is just a workaround. Robust solution would be to iterate over all
available authentication data and choose the right ones for registry
currently processed. And client would have to pass all possibly needed
credentials to docker daemon with any request (it does so only in rare
cases like docker build).

Signed-off-by: Michal Minar <miminar@redhat.com>

Signed-off-by: Dan Walsh <dwalsh@redhat.com>
---
 registry/session.go | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/registry/session.go b/registry/session.go
index d09babd..102263b 100644
--- a/registry/session.go
+++ b/registry/session.go
@@ -15,6 +15,7 @@ import (
 	"net/http"
 	"net/http/cookiejar"
 	"net/url"
+	"regexp"
 	"strconv"
 	"strings"
 
@@ -32,6 +33,7 @@ var (
 	// ErrRepoNotFound is returned if the repository didn't exist on the
 	// remote side
 	ErrRepoNotFound = errors.New("Repository not found")
+	reURLScheme     = regexp.MustCompile(`^[^:]+://`)
 )
 
 // A Session is used to communicate with a V1 registry
@@ -163,6 +165,18 @@ func (tr *authTransport) CancelRequest(req *http.Request) {
 // NewSession creates a new session
 // TODO(tiborvass): remove authConfig param once registry client v2 is vendored
 func NewSession(client *http.Client, authConfig *types.AuthConfig, endpoint *Endpoint) (r *Session, err error) {
+	if authConfig != nil && authConfig.ServerAddress != "" {
+		serverAddress := authConfig.ServerAddress
+		if !reURLScheme.MatchString(serverAddress) {
+			serverAddress = "http://" + serverAddress
+		}
+		parsed, err := url.Parse(serverAddress)
+		if err == nil && parsed.Host != endpoint.URL.Host {
+			logrus.Infof("authConfig does not conform to given endpoint (%s != %s)", parsed.Host, endpoint.URL.Host)
+			*authConfig = types.AuthConfig{}
+		}
+	}
+
 	r = &Session{
 		authConfig:    authConfig,
 		client:        client,
-- 
2.5.0

